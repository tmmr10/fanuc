PROGRAM tcpserv3
--%STACKSIZE = 4000
--%NOLOCKGROUP
--%NOPAUSE=ERROR+COMMAND+TPENABLE
--%ENVIRONMENT uif
--%ENVIRONMENT sysdef
--%ENVIRONMENT memo
--%ENVIRONMENT kclop
--%ENVIRONMENT bynam
--%ENVIRONMENT fdev
--%ENVIRONMENT flbt
--%ENVIRONMENT REGOPE
--%INCLUDE klevccdf
--%INCLUDE klevkeys
--%INCLUDE klevkmsk
-------------------------------------------------------------------------------
CONST
	Version		= '0.5.0'	
	--len_command	= 5             
    
    -- Funktion comands
    SHUTDOWN    = 'shutdown_server'
    PI_MOV      = 'move_via_piui'
    FINISH      = 'finished'
    
    -- Answer Messages
    ACK         = 'ack'
    FAILURE     = 'fail_'
    
    -- Failure Reasons
    OVERFLOW    = 'overflow'
    NODATA      = 'noData'  
    COORD       = 'coordinates'
    
	
VAR
	file_var 	: FILE	
	tmp_msg     : STRING[254]		-- max string length
	tmp_sub,
    answer      : STRING[127]
	--unfin_pos	: STRING[8]
	status,
    i_o_status,
	entry, 
	len_msg, 
	bytes_read,
	prog_index,						-- only declarated, not to be set/manipulated
	--unfin_pos_i,
    num_read_pos,
	global_pos	: INTEGER			
	loop,
	running,
    fnc_pi_mov  : BOOLEAN		    -- defines if prog is in pos reading mode and awaits block of positions
	xyzwpr_pos  : XYZWPR
	
-------------------------------------------------------------------------------
---- Section ROUTINES:
----					move_to_pr	zum lesen des Eingangsstreams und schreiben ins PosRegisters
----					fill_pos_ary
-------------------------------------------------------------------------------

ROUTINE clear_fnc
BEGIN
	
END clear_fnc

ROUTINE move_to_pr
BEGIN
	CALL_PROG('KAREL_MOVER', prog_index) 	-- call TP program for movement
    num_read_pos = 1
END move_to_pr

ROUTINE fill_pos_ary: BOOLEAN
VAR
	index,
	pos_index   : INTEGER	-- type of read input, 1 = pos_x, 2 = pos_y, 3 = pos_z, 4 = Linear/Joint 0/1		
	tmp_real	: REAL
	tmp_pos: STRING[8]	-- concated string representing axis pos value
	tmp_char: STRING[1]	
BEGIN
	
	tmp_char = ''
    xyzwpr_pos = CURPOS(0,0)		-- get current roboter position, for correct pos config data
    xyzwpr_pos.w = 30				-- static axis rotation values
    xyzwpr_pos.p = 0
    xyzwpr_pos.r = 180
    tmp_pos = ''
    pos_index = 1
    
	FOR index = 1 TO STR_LEN(tmp_msg) DO		
		tmp_char = SUB_STR(tmp_msg, index, 1)		-- cut of one char
		
		IF tmp_char = '|' THEN
			SELECT pos_index OF
			CASE(1):
				CNV_STR_REAL(tmp_pos, tmp_real)
				xyzwpr_pos.x = tmp_real
				pos_index = 2
				tmp_pos = ''
			CASE(2):
				CNV_STR_REAL(tmp_pos, tmp_real)
				xyzwpr_pos.y = tmp_real
				pos_index = 3
				tmp_pos = ''
			CASE(3):
				CNV_STR_REAL(tmp_pos, tmp_real)
				IF tmp_real > 0 THEN
					tmp_real = 0
				ENDIF
				xyzwpr_pos.z = tmp_real
				pos_index = 4
				tmp_pos = ''
			ELSE: 
			ENDSELECT
		ELSE
			IF tmp_char = ';' THEN
				IF tmp_pos = 'J' THEN
					SET_INT_REG(num_read_pos, 1, status)
				ELSE 
					SET_INT_REG(num_read_pos, 0, status)
				ENDIF
				pos_index = 1
				tmp_pos = ''
				
				SET_POS_REG(num_read_pos, xyzwpr_pos, status)
				num_read_pos = num_read_pos + 1
                global_pos = num_read_pos
			ELSE
            -- TODO test if char is number!
				tmp_pos = tmp_pos + tmp_char    -- concate axis pos value 
												-- ( '-1' = '-1' + '5' -> '-15' as axis value)
			ENDIF
		ENDIF	
		--fanuc only has 100 PosReg, start move after 100 positions, continue at pos 101  
		IF num_read_pos = 101 THEN		
			tmp_msg = SUB_STR(tmp_msg, index+1, STR_LEN(tmp_msg)-index)
			--WRITE(tmp_msg)		
			
			SET_INT_REG(101, num_read_pos-1, status)		-- save anz of positions
			move_to_pr
			
			index = 0
			num_read_pos = 1
		ENDIF
	ENDFOR
    
    -- if position wasn't read komplete, safe unfinishe bussines in global vars
    -- else clear global vars
    IF tmp_pos <> '' THEN
        --WRITE ('FAIL POS',cr)
        RETURN (FALSE)        
    ENDIF
    
	SET_INT_REG(101, num_read_pos-1, status)		-- save anz of positions
	--WRITE('Empfangene Positionen = ',num_read_pos-1,cr)
    
    RETURN (TRUE)
END fill_pos_ary

-------------------------------------------------------------------------------
---- Section Main Program
----					
-------------------------------------------------------------------------------
BEGIN    
	WRITE ('Server start v', Version, cr)
	fnc_pi_mov = FALSE
	running = TRUE	
    num_read_pos = 1	
    
	WHILE running DO
		SET_FILE_ATR(file_var, ATR_IA)
		-- set the server port before doing a connect
		SET_VAR(entry, '*SYSTEM*','$HOSTS_CFG[3].$SERVER_PORT',59002,status)
		MSG_CONNECT('S3:',status)
		WRITE('Connect Status = ',status,CR)
		IF status = 0 THEN
			-- Open S3:
			OPEN FILE file_var ('rw','S3:')						-- associate file variable to communication port
			status = IO_STATUS(file_var)			
			--WRITE ('Open File status: ',status,cr)
			IF status = 0 THEN
				loop = TRUE
				WHILE loop = TRUE DO
					BYTES_AHEAD(file_var, len_msg, status)		-- status = 0 -> file/msg is readable
					
					IF status <> 0 THEN
						--WRITE('Reading File failed..',cr)				
						IF status = 67212 THEN
							loop = FALSE
						ENDIF
					ELSE
						IF len_msg = 0 THEN
                            --answer = FAILURE + NODATA
                            --WRITE file_var(answer::STR_LEN(answer))
							--WRITE('No bytes to read..',cr)
						ELSE
							--WRITE('Bytes available to read:', len_msg,' status:', status, CR)
                            
							
                            -- test msg length
                            IF len_msg > 127 THEN
                                answer = FAILURE + OVERFLOW
                                WRITE file_var(answer::STR_LEN(answer))
                                WRITE ('To much Input to read', cr)
							ELSE
								bytes_read = len_msg
							
                                READ file_var (tmp_msg::bytes_read)
                                status = IO_STATUS(file_var)      
                                WRITE('Bytes: ', len_msg, 'status: ', status, cr,' Msg: ', tmp_msg, CR)                          
                                --WRITE ('IO-Status: ', status, CR)   
                                
                                IF status = 0 THEN
                                    
                                    --------------------------
                                    -- Move via Pi UI
                                    --------------------------                           
                                    -- read Block
                                    IF fnc_pi_mov AND (tmp_msg <> PI_MOV) AND (tmp_msg <> '') AND (tmp_msg <> FINISH) THEN
                                        IF fill_pos_ary THEN                                   
                                            answer = ACK                                        
                                        ELSE
                                            answer = FAILURE + COORD
                                        ENDIF
                                        
                                        WRITE file_var(answer::STR_LEN(answer))
                                    ENDIF   

                                    -- main function ack
                                    IF (tmp_msg = PI_MOV) AND (fnc_pi_mov = FALSE) THEN 					
                                        answer = ACK
                                        WRITE file_var(answer::STR_LEN(answer))
                                        
                                        fnc_pi_mov = TRUE   -- enable block reading function                           
                                    ENDIF 
                                    
                                    --------------------------
                                    -- Close active Funktion
                                    --------------------------
                                    IF tmp_msg = FINISH THEN                                    
                                        
                                        IF fnc_pi_mov THEN                                            
                                            move_to_pr
                                            fnc_pi_mov = FALSE
                                        ENDIF
                                        
                                        answer = ACK
                                        WRITE file_var(answer::STR_LEN(answer))
                                        
                                        fnc_pi_mov = FALSE   
                                    ENDIF 

                                    --------------------------
                                    -- Shutdown Server
                                    --------------------------
                                    IF tmp_msg = SHUTDOWN THEN
                                        answer = ACK
                                        WRITE file_var(answer::STR_LEN(answer))
                                        
                                        loop = FALSE
                                        running = FALSE
                                    ENDIF   
                                ELSE
                                    loop = FALSE
                                    fnc_pi_mov = FALSE
                                    num_read_pos = 1
                                    --WRITE('READ failed, Rollup is done', cr)
                                ENDIF
                            ENDIF
						ENDIF
					ENDIF
					IF fnc_pi_mov = FALSE THEN
						delay 700
					ENDIF
				ENDWHILE
				CLOSE FILE file_var
			ENDIF

			WRITE('Disconnecting..',cr)
			MSG_DISCO('S3:',status)
		ELSE
			MSG_DISCO('S3:',status)
			WRITE('Disconnecting..',cr)
		ENDIF
	ENDWHILE
END tcpserv3