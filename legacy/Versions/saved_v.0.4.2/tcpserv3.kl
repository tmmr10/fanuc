PROGRAM tcpserv3
%STACKSIZE = 4000
%NOLOCKGROUP
%NOPAUSE=ERROR+COMMAND+TPENABLE
%ENVIRONMENT uif
%ENVIRONMENT sysdef
%ENVIRONMENT memo
%ENVIRONMENT kclop
%ENVIRONMENT bynam
%ENVIRONMENT fdev
%ENVIRONMENT flbt
%ENVIRONMENT REGOPE
%INCLUDE klevccdf
%INCLUDE klevkeys
%INCLUDE klevkmsk
-------------------------------------------------------------------------------
CONST
	Version		= '0.4.2'	
	len_command	= 5
	
VAR
	file_var 	: FILE	
	tmp_msg,
	tmp_sub 	: STRING[128]
	unfin_pos	: STRING[8]
	status, 
	entry, 
	len_msg, 
	bytes_read,
	prog_index,						-- only declarated, not to be set/manipulated
	unfin_pos_i,
	unfin_r_pos	: INTEGER			
	loop,
	running,
	reading_pos		: BOOLEAN		-- defines is prog is in pos reading mode, 
									-- e.g. send pos-data greater than 128 range of READ statment
	xyzwpr_pos		: XYZWPR
	
-------------------------------------------------------------------------------
---- Section ROUTINES:
----					move_to_pr	zum lesen des Eingangsstreams und schreiben ins PosRegisters
----					fill_pos_ary
-------------------------------------------------------------------------------


ROUTINE move_to_pr
BEGIN
	CALL_PROG('KAREL_MOVER', prog_index) 	-- call TP program for movement
END move_to_pr

ROUTINE fill_pos_ary
VAR
	index,
	pos_index,				-- type of read input, 1 = pos_x, 2 = pos_y, 3 = pos_z, 4 = Linear/Joint 0/1
	num_read_pos : INTEGER	-- number of saved positions in PositionRegisters
	tmp_real	: REAL
	tmp_pos: STRING[8]	-- concated string representing axis pos value
	tmp_char: STRING[1]	
BEGIN
	
	
	tmp_char = ''
	
	-- check if there is unfinished bussines (unfinished positions read)
	-- and start at the old offset
	IF reading_pos = TRUE THEN
		tmp_pos = unfin_pos
		pos_index = unfin_pos_i
		num_read_pos = unfin_r_pos
	ELSE
		xyzwpr_pos = CURPOS(0,0)		-- get current roboter position, for correct pos config data
		xyzwpr_pos.w = 30				-- static axis rotation values
		xyzwpr_pos.p = 0
		xyzwpr_pos.r = 180
		tmp_pos = ''
		pos_index = 1
		num_read_pos = 1
	ENDIF	
									
	FOR index = 1 TO STR_LEN(tmp_msg) DO		
		tmp_char = SUB_STR(tmp_msg, index, 1)		-- cut of one char
		
		IF tmp_char = '|' THEN
			SELECT pos_index OF
			CASE(1):
				CNV_STR_REAL(tmp_pos, tmp_real)
				xyzwpr_pos.x = tmp_real
				pos_index = 2
				tmp_pos = ''
			CASE(2):
				CNV_STR_REAL(tmp_pos, tmp_real)
				xyzwpr_pos.y = tmp_real
				pos_index = 3
				tmp_pos = ''
			CASE(3):
				CNV_STR_REAL(tmp_pos, tmp_real)
				IF tmp_real > 0 THEN
					tmp_real = 0
				ENDIF
				xyzwpr_pos.z = tmp_real
				pos_index = 4
				tmp_pos = ''
			ELSE: 
			ENDSELECT
		ELSE
			IF tmp_char = ';' THEN
				IF tmp_pos = 'J' THEN
					SET_INT_REG(num_read_pos, 1, status)
				ELSE 
					SET_INT_REG(num_read_pos, 0, status)
				ENDIF
				pos_index = 1
				tmp_pos = ''
				
				SET_POS_REG(num_read_pos, xyzwpr_pos, status)
				num_read_pos = num_read_pos + 1
			ELSE
				tmp_pos = tmp_pos + tmp_char    -- concate axis pos value 
												-- ( '-1' = '-1' + '5' -> '-15' as axis value)
			ENDIF
		ENDIF	
		--fanuc only has 100 PosReg, start move after 100 positions, continue at pos 101  
		IF num_read_pos = 101 THEN		
			tmp_msg = SUB_STR(tmp_msg, index+1, STR_LEN(tmp_msg)-index)
			WRITE(tmp_msg)		
			
			SET_INT_REG(101, num_read_pos-1, status)		-- save anz of positions
			move_to_pr
			
			index = 0
			num_read_pos = 1
		ENDIF
		
		-- if position wasn't read komplete, safe unfinishe bussines in global vars
		-- else clear global vars
		IF tmp_pos <> '' THEN
			unfin_pos = tmp_pos
			unfin_pos_i = pos_index	
			unfin_r_pos = num_read_pos
		--ELSE
			--unfin_pos = ''
		ENDIF
	ENDFOR
	SET_INT_REG(101, num_read_pos-1, status)		-- save anz of positions
	WRITE('Empfangene Positionen = ',num_read_pos-1,cr)
END fill_pos_ary

-------------------------------------------------------------------------------
---- Section Main Program
----					
-------------------------------------------------------------------------------
BEGIN
	WRITE ('Server start v', Version, cr)
	unfin_pos = ''
	running = TRUE	
	reading_pos = FALSE	
	WHILE running DO
		SET_FILE_ATR(file_var, ATR_IA)
		-- set the server port before doing a connect
		SET_VAR(entry, '*SYSTEM*','$HOSTS_CFG[3].$SERVER_PORT',59002,status)
		MSG_CONNECT('S3:',status)
		WRITE('Connect Status = ',status,cr)
		IF status = 0 THEN
			-- Open S3:
			OPEN FILE file_var ('rw','S3:')
			status = IO_STATUS(file_var)			
			--WRITE ('Open File status: ',status,cr)
			IF status = 0 THEN
				loop = TRUE
				WHILE loop = TRUE DO
					BYTES_AHEAD(file_var, len_msg, status)		-- status = 0 -> file/msg is readable
					
					IF status <> 0 THEN
						--WRITE('Reading File failed..',cr)				
						IF status = 67212 THEN
							loop = FALSE
						ENDIF
					ELSE
						IF len_msg = 0 THEN
							--WRITE('No bytes to read..',cr)
						ELSE
							--Verarbeitung der Übergabe
							WRITE('Bytes available to read:', len_msg,' status:', status, cr)
							IF len_msg > 128 THEN
								bytes_read = 128
							ELSE
								bytes_read = len_msg
							ENDIF
							READ file_var (tmp_msg::bytes_read)
							status = IO_STATUS(file_var)
							WRITE ('Nachricht:', tmp_msg::STR_LEN(tmp_msg), cr)		
					
							IF reading_pos = FALSE THEN							-- need substring only if not already started reading positions
								
								tmp_sub = SUB_STR(tmp_msg, 1, len_command)	-- get command 
								tmp_msg = SUB_STR(tmp_msg, len_command + 1, STR_LEN(tmp_msg))		-- get only msg without command
							ENDIF
							IF tmp_sub = 'close' THEN
								loop = FALSE
								running = FALSE
							ENDIF
							IF tmp_sub = 'mover' THEN
								CALL_PROG('KAREL_MOVER', prog_index)
							ENDIF
							IF tmp_sub ='koord' THEN -- koordinaten								
	
								--erwarte Stream von Koordinaten
								-- Koordinaten sind durch ';' voneinander getrennt, xyz mit '|'
								fill_pos_ary
								
								IF len_msg > 128 THEN
									reading_pos = TRUE
								ELSE
									reading_pos = FALSE
									move_to_pr
								ENDIF
								
							ENDIF
						ENDIF
					ENDIF
					IF reading_pos = FALSE THEN
						delay 700
					ENDIF
				ENDWHILE
				CLOSE FILE file_var
			ENDIF

			WRITE('Disconnecting..',cr)
			MSG_DISCO('S3:',status)
		ELSE
			MSG_DISCO('S3:',status)
			WRITE('Disconnecting..',cr)
		ENDIF
	ENDWHILE
END tcpserv3